<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Indic Text Compressor - Enhanced Edition</title>
  <link rel="stylesheet" href="./styles.css">
  <style>
    /* Additional styles for enhanced features */
    .patent-badge {
      display: inline-block;
      padding: 4px 12px;
      background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
      color: white;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 700;
      margin-left: 8px;
      box-shadow: 0 2px 8px rgba(238, 90, 111, 0.3);
    }
    
    .feature-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
    }
    
    .feature-card h3 {
      margin: 0 0 8px 0;
      font-size: 1.1rem;
    }
    
    .feature-card p {
      margin: 0;
      opacity: 0.95;
      font-size: 0.9rem;
    }
    
    .quality-selector {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 12px;
    }
    
    .quality-option {
      flex: 1;
      min-width: 100px;
      padding: 10px;
      border: 2px solid var(--border);
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      background: var(--bg-secondary);
    }
    
    .quality-option:hover {
      border-color: var(--primary);
      transform: translateY(-2px);
    }
    
    .quality-option.active {
      border-color: var(--primary);
      background: var(--primary);
      color: white;
      font-weight: 700;
    }
    
    .quality-label {
      font-size: 0.85rem;
      font-weight: 600;
    }
    
    .quality-desc {
      font-size: 0.7rem;
      margin-top: 4px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <main class="container">
    <header class="header">
      <h1>
        Indic Text Compressor
      </h1>
      <p class="subtitle">Advanced Lossy Compression for Indic Scripts</p>
      <p id="wasmStatus" style="margin-top: 10px; color: #ffc107; font-size: 0.9rem;">Loading WASM...</p>
    </header>

    <!-- Feature Highlights -->
    <div class="feature-card">
      <h3>Novel Innovation</h3>
      <p><strong>Script-Aware Lossy Compression:</strong> Phonetically-equivalent normalization preserves meaning while reducing size by 5-20%.</p>
    </div>

    <!-- Main Input Section -->
    <section class="panel">
      <h2>Input Text</h2>
      <label for="inputText" class="label">Enter text in any Indic script (Hindi, Tamil, Telugu, Bengali, etc.)</label>
      <textarea 
        id="inputText" 
        class="textbox" 
        placeholder="Type or paste Indic text here..."
        spellcheck="false"
      ></textarea>
      
      <div class="stats-row">
        <div class="stat">
          <span class="stat-label">Characters:</span>
          <span id="charCount" class="stat-value">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">Bytes (UTF-8):</span>
          <span id="byteCount" class="stat-value">0</span>
        </div>
      </div>
    </section>

    <!-- Lossy Compression Settings -->
    <section class="panel">
      <h2>Lossy Compression Quality</h2>
      
      <div class="setting-group">
        <label class="label">
          Select Quality Level
          <span class="help-icon" title="Trade quality for better compression. Lossless = perfect reconstruction, Lower quality = more compression.">‚ÑπÔ∏è</span>
        </label>
        
        <div class="quality-selector">
          <div class="quality-option active" data-quality="0">
            <div class="quality-label">Lossless</div>
            <div class="quality-desc">100% perfect</div>
          </div>
          <div class="quality-option" data-quality="1">
            <div class="quality-label">Very High</div>
            <div class="quality-desc">~99% quality</div>
          </div>
          <div class="quality-option" data-quality="2">
            <div class="quality-label">High</div>
            <div class="quality-desc">~95% quality</div>
          </div>
          <div class="quality-option" data-quality="3">
            <div class="quality-label">Medium</div>
            <div class="quality-desc">~85% quality</div>
          </div>
          <div class="quality-option" data-quality="4">
            <div class="quality-label">Low</div>
            <div class="quality-desc">~70% quality</div>
          </div>
        </div>
        
        <div id="lossySavings" style="margin-top: 12px; font-size: 0.9rem; color: var(--text-muted);">
          Estimated lossy savings: <strong>0.0%</strong>
        </div>
      </div>
    </section>

    <!-- Neural-Hybrid Compression -->
    <section class="panel">
      <h2>Neural-Hybrid Compression</h2>
      <div class="feature-card" style="margin-bottom: 16px;">
        <p>Combines lightweight neural network with PPM for 5-15% better compression!</p>
      </div>
      
      <div class="setting-group">
        <label class="checkbox-label">
          <input type="checkbox" id="useNeural">
          Enable Neural Predictor
        </label>
        <p class="help-text" style="margin-top: 4px; font-size: 0.85rem;">
          Uses a tiny (~50KB) neural network to improve token prediction
        </p>
      </div>

      <div id="neuralWeightGroup" class="setting-group" style="display: none; margin-top: 16px;">
        <label for="neuralWeight" class="label">
          Neural Weight (Œ±)
          <span class="help-icon" title="0% = Pure PPM, 100% = Pure Neural. Recommended: 30-50%">‚ÑπÔ∏è</span>
        </label>
        <div class="input-with-display">
          <input id="neuralWeight" type="range" value="30" min="0" max="100" step="5" class="slider">
          <span id="neuralWeightDisplay" class="value-display">30%</span>
        </div>
      </div>
    </section>

    <!-- Standard Compression Settings -->
    <section class="panel">
      <h2>Compression Settings</h2>
      
      <div class="setting-group">
        <label for="chunkSize" class="label">
          Chunk Size (tokens per chunk)
          <span class="help-icon" title="Number of grapheme clusters processed together. Smaller chunks = faster progressive decoding, larger chunks = better compression.">‚ÑπÔ∏è</span>
        </label>
        <div class="input-with-display">
          <input id="chunkSize" type="range" value="40" min="10" max="200" step="10" class="slider">
          <span id="chunkSizeDisplay" class="value-display">40</span>
        </div>
      </div>

      <div class="button-group">
        <button id="btnEncode" class="btn btn-primary" disabled>
          üóúÔ∏è Compress Text
        </button>
        <button id="btnClear" class="btn btn-secondary">
          Clear
        </button>
      </div>
    </section>

    <!-- Compression Results -->
    <section class="panel" id="resultsPanel" style="display: none;">
      <h2>Compression Results</h2>
      
      <div class="results-grid">
        <div class="result-card">
          <div class="result-label">Original Size</div>
          <div id="originalSize" class="result-value">‚Äî bytes</div>
        </div>
        <div class="result-card">
          <div class="result-label">Compressed Size</div>
          <div id="compressedSize" class="result-value">‚Äî bytes</div>
        </div>
        <div class="result-card">
          <div class="result-label">Compression Ratio</div>
          <div id="compressionRatio" class="result-value">‚Äî</div>
        </div>
        <div class="result-card">
          <div class="result-label">Number of Chunks</div>
          <div id="chunkCount" class="result-value">‚Äî</div>
        </div>
        <div class="result-card">
          <div class="result-label">Method Used</div>
          <div id="methodUsed" class="result-value">‚Äî</div>
        </div>
      </div>

      <div class="button-group">
        <button id="btnDownload" class="btn btn-primary">
          Download .bin
        </button>
        <button id="btnDecodeAll" class="btn btn-secondary">
          ‚úì Decompress & Verify
        </button>
      </div>
    </section>

    <!-- Upload .bin -->
    <section class="panel" id="uploadSection">
      <h2>Load Compressed File (.bin)</h2>
      <p class="muted">Load a previously saved compressed stream to decompress or preview</p>

      <div id="uploadArea" class="upload-area">
        <div class="upload-left">
          <input id="fileInput" type="file" accept=".bin,application/octet-stream" />
          <button id="btnLoadFile" class="btn">Load File</button>
        </div>

        <div class="upload-right">
          <div id="uploadedInfo" class="upload-info">No file loaded</div>
          <div class="upload-actions">
            <button id="btnDecodeUpload" class="btn btn-primary">Decompress File</button>
            <button id="btnClearUpload" class="btn btn-secondary">Clear</button>
          </div>
        </div>
      </div>
    </section>

    <!-- Progressive Decoding -->
    <section class="panel" id="decodePanel" style="display: none;">
      <h2>Progressive Decoding</h2>
      <p class="info-text">Decode only part of the compressed stream (useful for previews)</p>
      
      <div class="setting-group">
        <label for="chunkToDecode" class="label">
          Decode up to chunk #
          <span class="help-icon" title="Decode only the first N chunks without decompressing everything.">‚ÑπÔ∏è</span>
        </label>
        <div class="input-with-display">
          <input id="chunkToDecode" type="range" value="0" min="0" max="0" class="slider">
          <span id="chunkToDecodeDisplay" class="value-display">0</span>
        </div>
      </div>

      <div class="button-group">
        <button id="btnDecodePrefix" class="btn btn-primary">
          ‚ñ∂ Decode Partial
        </button>
      </div>
    </section>

    <!-- Decoded Output -->
    <section class="panel" id="outputPanel" style="display: none;">
      <h2>Decoded Output</h2>
      <div class="output-header">
        <span id="outputStatus" class="status-badge">‚Äî</span>
        <button id="btnCopyOutput" class="btn btn-small">Copy</button>
      </div>
      <pre id="decodedOutput" class="output">Decoded text will appear here...</pre>
    </section>

    <!-- Help Section -->
    <section class="panel help-section">
      <h2>How to Use</h2>
      <div class="help-content">
        <div class="help-item">
          <strong>1. Enter Text:</strong> Type or paste Indic script text. Works with Devanagari, Tamil, Telugu, Bengali, Gujarati, Malayalam, Kannada, and more.
        </div>
        <div class="help-item">
          <strong>2. Select Quality:</strong> Choose compression quality level. Lossless preserves every character perfectly. Lossy modes apply phonetically-equivalent substitutions for better compression.
        </div>
        <div class="help-item">
          <strong>3. Compress:</strong> Click "Compress Text". The algorithm uses PPM (Prediction by Partial Matching) with rANS (range Asymmetric Numeral Systems) entropy coding.
        </div>
        <div class="help-item">
          <strong>4. Download:</strong> Save the compressed .bin file for later use.
        </div>
        <div class="help-item">
          <strong>5. Verify:</strong> Click "Decompress & Verify" to check the compressed text matches the original (for lossless) or quality level (for lossy).
        </div>
      </div>
    </section>

    <!-- Status Toast -->
    <div id="statusToast" class="toast hidden">
      <span id="toastMessage"></span>
    </div>
  </main>

  <script type="module">
    console.log('Indic Compressor - Starting initialization...');
    
    let wasmReady = false;
    let wasmModule = null;
    let latestStreamBytes = null;
    let latestOriginalText = '';
    let currentQuality = 0;
    let useNeural = false;
    let neuralWeight = 0.30;

    function updateWasmStatus(status, message) {
      const statusEl = document.getElementById('wasmStatus');
      const btnEncode = document.getElementById('btnEncode');
      
      if (statusEl) {
        if (status === 'loading') {
          statusEl.textContent = message;
          statusEl.style.color = '#ffc107';
        } else if (status === 'ready') {
          statusEl.textContent = message;
          statusEl.style.color = '#198754';
          if (btnEncode) btnEncode.disabled = false;
        } else if (status === 'error') {
          statusEl.textContent = message;
          statusEl.style.color = '#dc3545';
        }
      }
    }

    function showToast(message, type = 'info') {
      const toast = document.getElementById('statusToast');
      const toastMsg = document.getElementById('toastMessage');
      
      if (toastMsg) toastMsg.textContent = message;
      if (toast) {
        toast.className = `toast ${type}`;
        toast.classList.remove('hidden');
        setTimeout(() => toast.classList.add('hidden'), 3000);
      }
    }

    function updateStats() {
      const text = document.getElementById('inputText')?.value || '';
      const chars = text.length;
      const bytes = new TextEncoder().encode(text).length;
      
      const charCount = document.getElementById('charCount');
      const byteCount = document.getElementById('byteCount');
      if (charCount) charCount.textContent = chars.toLocaleString();
      if (byteCount) byteCount.textContent = bytes.toLocaleString();
      
      // Update lossy savings
      if (wasmReady && wasmModule && wasmModule.estimate_lossy_savings && text) {
        try {
          const savings = wasmModule.estimate_lossy_savings(text, currentQuality);
          const lossySavings = document.getElementById('lossySavings');
          if (lossySavings) {
            lossySavings.innerHTML = `Estimated lossy savings: <strong>${savings}</strong>`;
          }
        } catch (e) {
          console.error('Error estimating savings:', e);
        }
      }
    }

    function updateSliderFill(slider) {
      if (!slider) return;
      const min = Number(slider.min || 0);
      const max = Number(slider.max || 100);
      const val = Number(slider.value);
      const percent = max === min ? 0 : (val - min) / (max - min) * 100;
      slider.style.background = `linear-gradient(90deg, var(--primary) ${percent}%, var(--border) ${percent}%)`;
    }

    function countChunksFromBinary(u8) {
      if (!u8 || u8.length < 2) return 0;
      
      // Check for uncompressed format
      if (u8[0] === 0x55 && u8[1] === 0x43) return 1; // "UC"
      if (u8[0] === 0x55 && u8[1] === 0x4C) return 1; // "UL"
      
      // Skip metadata if present  
      let offset = 0;
      if (u8[0] === 0x49 && u8[1] === 0x4C) { // "IL"
        if (u8.length < 3) return 0;
        const metaLen = u8[2];
        offset = 3 + metaLen;
      }
      
      // Count IC chunks
      if (u8[offset] !== 0x49 || u8[offset + 1] !== 0x43) return 0;

      const dv = new DataView(u8.buffer, u8.byteOffset + offset, u8.byteLength - offset);
      let pos = 0;
      let count = 0;
      
      try {
        while (pos + 2 <= u8.length - offset) {
          if (u8[offset + pos] !== 0x49 || u8[offset + pos + 1] !== 0x43) break;
          pos += 2;
          
          if (pos + 2 > u8.length - offset) break;
          const token_count = dv.getUint16(pos, false);
          pos += 2;
          
          if (pos + 1 > u8.length - offset) break;
          const delta_count = u8[offset + pos];
          pos += 1;
          
          for (let i = 0; i < delta_count; i++) {
            if (pos + 3 > u8.length - offset) { pos = u8.length - offset; break; }
            pos += 2;
            const len = u8[offset + pos];
            pos += 1;
            if (pos + len > u8.length - offset) { pos = u8.length - offset; break; }
            pos += len;
          }
          
          if (pos + token_count > u8.length - offset) break;
          pos += token_count;
          
          if (pos + 2 > u8.length - offset) break;
          const payload_len = dv.getUint16(pos, false);
          pos += 2;
          
          if (pos + payload_len > u8.length - offset) break;
          pos += payload_len;
          
          count++;
        }
      } catch (e) {
        console.error('Error parsing chunks:', e);
      }
      
      return count;
    }

    function initControls() {
      // Chunk size slider
      const chunkSize = document.getElementById('chunkSize');
      const chunkSizeDisplay = document.getElementById('chunkSizeDisplay');
      if (chunkSize && chunkSizeDisplay) {
        chunkSizeDisplay.textContent = chunkSize.value;
        chunkSize.addEventListener('input', () => {
          chunkSizeDisplay.textContent = chunkSize.value;
          updateSliderFill(chunkSize);
        });
        updateSliderFill(chunkSize);
      }

      // Decode slider
      const chunkToDecode = document.getElementById('chunkToDecode');
      const chunkToDecodeDisplay = document.getElementById('chunkToDecodeDisplay');
      if (chunkToDecode && chunkToDecodeDisplay) {
        chunkToDecodeDisplay.textContent = chunkToDecode.value;
        chunkToDecode.addEventListener('input', () => {
          chunkToDecodeDisplay.textContent = chunkToDecode.value;
          updateSliderFill(chunkToDecode);
        });
        updateSliderFill(chunkToDecode);
      }

      // Quality selector
      const qualityOptions = document.querySelectorAll('.quality-option');
      qualityOptions.forEach(option => {
        option.addEventListener('click', () => {
          qualityOptions.forEach(opt => opt.classList.remove('active'));
          option.classList.add('active');
          currentQuality = parseInt(option.getAttribute('data-quality'));
          updateStats();
        });
      });

      // Neural toggle
      const neuralCheckbox = document.getElementById('useNeural');
      const neuralWeightGroup = document.getElementById('neuralWeightGroup');
      if (neuralCheckbox && neuralWeightGroup) {
        neuralCheckbox.addEventListener('change', () => {
          useNeural = neuralCheckbox.checked;
          neuralWeightGroup.style.display = useNeural ? 'block' : 'none';
          if (useNeural) {
            showToast('Neural predictor enabled - compression will improve!', 'success');
          }
        });
      }

      // Neural weight slider
      const neuralWeightSlider = document.getElementById('neuralWeight');
      const neuralWeightDisplay = document.getElementById('neuralWeightDisplay');
      if (neuralWeightSlider && neuralWeightDisplay) {
        neuralWeightDisplay.textContent = neuralWeightSlider.value + '%';
        neuralWeightSlider.addEventListener('input', () => {
          neuralWeight = parseInt(neuralWeightSlider.value) / 100.0;
          neuralWeightDisplay.textContent = neuralWeightSlider.value + '%';
          updateSliderFill(neuralWeightSlider);
        });
        updateSliderFill(neuralWeightSlider);
      }

      // Text input
      const inputText = document.getElementById('inputText');
      if (inputText) {
        inputText.addEventListener('input', updateStats);
      }

      // Buttons
      const btnClear = document.getElementById('btnClear');
      if (btnClear) {
        btnClear.addEventListener('click', () => {
          if (inputText) inputText.value = '';
          updateStats();
          const panels = ['resultsPanel', 'decodePanel', 'outputPanel'];
          panels.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.style.display = 'none';
          });
          showToast('Cleared', 'success');
        });
      }

      const btnEncode = document.getElementById('btnEncode');
      if (btnEncode) btnEncode.addEventListener('click', handleEncode);

      const btnDecodeAll = document.getElementById('btnDecodeAll');
      if (btnDecodeAll) btnDecodeAll.addEventListener('click', handleDecode);

      const btnDecodePrefix = document.getElementById('btnDecodePrefix');
      if (btnDecodePrefix) btnDecodePrefix.addEventListener('click', handleDecodePrefix);

      const btnCopyOutput = document.getElementById('btnCopyOutput');
      if (btnCopyOutput) {
        btnCopyOutput.addEventListener('click', async () => {
          const text = document.getElementById('decodedOutput')?.textContent || '';
          try {
            await navigator.clipboard.writeText(text);
            showToast('Copied to clipboard', 'success');
          } catch (e) {
            showToast('Failed to copy', 'error');
          }
        });
      }

      // File upload
      const btnLoadFile = document.getElementById('btnLoadFile');
      const fileInput = document.getElementById('fileInput');
      if (btnLoadFile && fileInput) {
        btnLoadFile.addEventListener('click', async () => {
          if (!fileInput.files || fileInput.files.length === 0) {
            showToast('Please choose a .bin file first', 'warning');
            return;
          }
          await loadBinFile(fileInput.files[0]);
        });
      }

      const btnDecodeUpload = document.getElementById('btnDecodeUpload');
      if (btnDecodeUpload) {
        btnDecodeUpload.addEventListener('click', handleDecode);
      }

      const btnClearUpload = document.getElementById('btnClearUpload');
      if (btnClearUpload) {
        btnClearUpload.addEventListener('click', () => {
          latestStreamBytes = null;
          if (fileInput) fileInput.value = '';
          const uploadedInfo = document.getElementById('uploadedInfo');
          if (uploadedInfo) uploadedInfo.textContent = 'No file loaded';
          const panels = ['resultsPanel', 'decodePanel', 'outputPanel'];
          panels.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.style.display = 'none';
          });
          showToast('‚úì Cleared', 'info');
        });
      }

      // Drag and drop
      const uploadArea = document.getElementById('uploadArea');
      if (uploadArea) {
        uploadArea.addEventListener('dragover', (e) => {
          e.preventDefault();
          uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
          uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', async (e) => {
          e.preventDefault();
          uploadArea.classList.remove('dragover');
          if (e.dataTransfer?.files && e.dataTransfer.files.length > 0) {
            await loadBinFile(e.dataTransfer.files[0]);
          }
        });
      }
    }

    async function loadBinFile(file) {
      try {
        const ab = await file.arrayBuffer();
        latestStreamBytes = new Uint8Array(ab);
        const chunks = countChunksFromBinary(latestStreamBytes);
        
        const uploadedInfo = document.getElementById('uploadedInfo');
        if (uploadedInfo) {
          uploadedInfo.textContent = `${file.name} ‚Äî ${file.size.toLocaleString()} bytes`;
        }

        const chunkCount = document.getElementById('chunkCount');
        if (chunkCount) chunkCount.textContent = chunks.toLocaleString();

        const chunkToDecode = document.getElementById('chunkToDecode');
        const chunkToDecodeDisplay = document.getElementById('chunkToDecodeDisplay');
        if (chunkToDecode && chunkToDecodeDisplay) {
          chunkToDecode.max = chunks;
          chunkToDecode.value = chunks;
          chunkToDecodeDisplay.textContent = chunks;
          updateSliderFill(chunkToDecode);
        }

        const resultsPanel = document.getElementById('resultsPanel');
        const decodePanel = document.getElementById('decodePanel');
        if (resultsPanel) resultsPanel.style.display = 'block';
        if (decodePanel && chunks > 0) decodePanel.style.display = 'block';
        
        showToast(`‚úì Loaded ${file.name}`, 'success');
      } catch (e) {
        showToast(`Failed to load file: ${e}`, 'error');
      }
    }

    async function handleEncode() {
      if (!wasmReady || !wasmModule) {
        showToast('WASM not ready', 'error');
        return;
      }

      try {
        const text = document.getElementById('inputText')?.value.trim() || '';
        if (!text) {
          showToast('Please enter some text', 'warning');
          return;
        }

        latestOriginalText = text;
        const originalBytes = new TextEncoder().encode(text).length;
        const chunkSize = Number(document.getElementById('chunkSize')?.value) || 40;

        const btn = document.getElementById('btnEncode');
        if (btn) {
          btn.disabled = true;
          btn.textContent = 'Compressing...';
        }

        // Use advanced encoding with lossy and neural support
        let encoded;
        if (useNeural || currentQuality > 0) {
          encoded = wasmModule.encode_stream_advanced_wasm(
            text,
            chunkSize,
            useNeural,
            neuralWeight,
            currentQuality
          );
        } else {
          encoded = wasmModule.encode_stream_wasm(text, chunkSize);
        }

        const u8 = new Uint8Array(encoded);
        latestStreamBytes = u8;

        const compressedBytes = u8.length;
        const ratio = (compressedBytes / Math.max(1, originalBytes) * 100).toFixed(1);
        const savings = originalBytes - compressedBytes;
        const chunks = countChunksFromBinary(u8);

        const originalSize = document.getElementById('originalSize');
        const compressedSize = document.getElementById('compressedSize');
        const compressionRatio = document.getElementById('compressionRatio');
        const chunkCount = document.getElementById('chunkCount');

        if (originalSize) originalSize.textContent = `${originalBytes.toLocaleString()} bytes`;
        if (compressedSize) compressedSize.textContent = `${compressedBytes.toLocaleString()} bytes`;
        if (chunkCount) chunkCount.textContent = chunks.toLocaleString();
        
        if (compressionRatio) {
          compressionRatio.textContent = `${ratio}% (saved ${savings.toLocaleString()} bytes)`;
          showToast(`‚úì Compressed to ${ratio}%`, 'success');
        } else {
          if (compressionRatio) compressionRatio.textContent = `${ratio}%`;
          showToast(`‚ö† Result is ${ratio}%`, 'warning');
        }

        // Show method used
        let method = 'PPM + rANS';
        if (useNeural) {
          method = `Neural-Hybrid (Œ±=${Math.round(neuralWeight*100)}%)`;
        }
        if (currentQuality > 0) {
          const qualityNames = ['Lossless', 'Very High', 'High', 'Medium', 'Low'];
          method += ` + Lossy (${qualityNames[currentQuality]})`;
        }
        
        const methodUsed = document.getElementById('methodUsed');
        if (methodUsed) {
          methodUsed.textContent = method;
          if (useNeural) {
            methodUsed.style.color = '#667eea';
            methodUsed.style.fontWeight = '700';
          }
        }

        // Update decode slider
        const chunkToDecode = document.getElementById('chunkToDecode');
        const chunkToDecodeDisplay = document.getElementById('chunkToDecodeDisplay');
        if (chunkToDecode && chunkToDecodeDisplay) {
          chunkToDecode.max = chunks;
          chunkToDecode.value = chunks;
          chunkToDecodeDisplay.textContent = chunks;
          updateSliderFill(chunkToDecode);
        }

        const resultsPanel = document.getElementById('resultsPanel');
        const decodePanel = document.getElementById('decodePanel');
        if (resultsPanel) resultsPanel.style.display = 'block';
        if (decodePanel && chunks > 1) decodePanel.style.display = 'block';

        // Download handler
        const downloadBtn = document.getElementById('btnDownload');
        if (downloadBtn) {
          downloadBtn.onclick = () => {
            const blob = new Blob([u8], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'indic_compressed.bin';
            a.click();
            URL.revokeObjectURL(url);
            showToast('‚úì Downloaded', 'success');
          };
        }

        if (btn) {
          btn.disabled = false;
          btn.textContent = 'Compress Text';
        }

      } catch (e) {
        console.error('Encode error:', e);
        showToast(`Error: ${e.message || e}`, 'error');
        const btn = document.getElementById('btnEncode');
        if (btn) {
          btn.disabled = false;
          btn.textContent = 'üóúÔ∏è Compress Text';
        }
      }
    }

    async function handleDecode() {
      if (!wasmReady || !wasmModule || !latestStreamBytes) {
        showToast('No data to decode', 'warning');
        return;
      }

      try {
        const btn = document.getElementById('btnDecodeAll') || document.getElementById('btnDecodeUpload');
        if (btn) {
          btn.disabled = true;
          btn.textContent = 'Decompressing...';
        }

        const decoded = wasmModule.decode_full_wasm(latestStreamBytes);

        const decodedOutput = document.getElementById('decodedOutput');
        const outputPanel = document.getElementById('outputPanel');
        const outputStatus = document.getElementById('outputStatus');

        if (decodedOutput) decodedOutput.textContent = decoded;
        if (outputPanel) outputPanel.style.display = 'block';

        if (latestOriginalText && outputStatus) {
          if (currentQuality === 0 && decoded === latestOriginalText) {
            outputStatus.textContent = '‚úì Perfect match';
            outputStatus.className = 'status-badge success';
            showToast('‚úì Perfect decompression!', 'success');
          } else if (currentQuality > 0) {
            outputStatus.textContent = '‚úì Lossy decompression complete';
            outputStatus.className = 'status-badge info';
            showToast('‚úì Lossy decompression complete', 'success');
          } else {
            outputStatus.textContent = '‚ö† Mismatch';
            outputStatus.className = 'status-badge warning';
            showToast('‚ö† Decoded text differs', 'warning');
          }
        } else if (outputStatus) {
          outputStatus.textContent = '‚úì Decompressed';
          outputStatus.className = 'status-badge info';
          showToast('‚úì Decompression complete', 'success');
        }

        if (btn) {
          btn.disabled = false;
          btn.textContent = btn.id === 'btnDecodeAll' ? '‚úì Decompress & Verify' : 'Decompress File';
        }

      } catch (e) {
        console.error('Decode error:', e);
        showToast(`Decode error: ${e.message || e}`, 'error');
        const btn = document.getElementById('btnDecodeAll') || document.getElementById('btnDecodeUpload');
        if (btn) {
          btn.disabled = false;
          btn.textContent = btn.id === 'btnDecodeAll' ? '‚úì Decompress & Verify' : 'Decompress File';
        }
      }
    }

    async function handleDecodePrefix() {
      if (!wasmReady || !wasmModule || !latestStreamBytes) {
        showToast('No data available', 'warning');
        return;
      }

      try {
        const upto = Math.max(0, Number(document.getElementById('chunkToDecode')?.value) || 0);
        
        if (upto === 0) {
          showToast('Please select at least 1 chunk', 'warning');
          return;
        }

        const btn = document.getElementById('btnDecodePrefix');
        if (btn) {
          btn.disabled = true;
          btn.textContent = 'Decoding...';
        }

        const decoded = wasmModule.decode_prefix_wasm(latestStreamBytes, upto);

        const decodedOutput = document.getElementById('decodedOutput');
        const outputPanel = document.getElementById('outputPanel');
        const outputStatus = document.getElementById('outputStatus');

        if (decodedOutput) decodedOutput.textContent = decoded;
        if (outputPanel) outputPanel.style.display = 'block';
        if (outputStatus) {
          outputStatus.textContent = `Partial decode (${upto} chunk${upto !== 1 ? 's' : ''})`;
          outputStatus.className = 'status-badge info';
        }

        showToast(`‚úì Decoded first ${upto} chunk${upto !== 1 ? 's' : ''}`, 'success');

        if (btn) {
          btn.disabled = false;
          btn.textContent = '‚ñ∂ Decode Partial';
        }

      } catch (e) {
        console.error('Decode prefix error:', e);
        showToast(`Partial decode failed: ${e.message || e}`, 'error');
        const btn = document.getElementById('btnDecodePrefix');
        if (btn) {
          btn.disabled = false;
          btn.textContent = '‚ñ∂ Decode Partial';
        }
      }
    }

    async function initWasm() {
      console.log('Initializing WASM...');
      updateWasmStatus('loading', 'Loading WASM module...');

      try {
        const module = await import('./pkg/indic_ans_compressor.js');
        console.log('WASM module imported');
        
        updateWasmStatus('loading', 'Initializing WASM...');
        await module.default();
        
        wasmModule = module;
        wasmReady = true;
        
        console.log('WASM initialized successfully');
        updateWasmStatus('ready', 'Ready to compress!');
        showToast('Ready to compress', 'success');
        
        updateStats();

      } catch (err) {
        console.error('WASM init failed:', err);
        updateWasmStatus('error', 'Failed to load WASM');
        showToast('WASM failed to load. Build with: wasm-pack build --target web --out-dir web/pkg', 'error');
      }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOM loaded, initializing controls...');
      initControls();
      updateStats();
      initWasm();
    });
  </script>
</body>
</html>